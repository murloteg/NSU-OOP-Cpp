CalcSin:
        pushq   %rbp // на вершину стека кладется база стекового фрейма rbp.
        movq    %rsp, %rbp // в регистр rbp копируется адрес верхушки стека.
        movl    %edi, -36(%rbp) // в значение, лежащее по адресу (rbp - 36) копируется number.
        movsd   %xmm0, -48(%rbp) // в значение, лежащее по адресу (rbp - 48) копируется argument.
        pxor    %xmm0, %xmm0 // обнуление регистра xmm0.
        movsd   %xmm0, -8(%rbp) // в значение, расположенное по адресу (rbp - 8), копируется 0 (result).
        movl    $1, -12(%rbp) // в значение, расположенное по адресу (rbp - 12), копируется 1 (signStatus).
        movsd   .LC1(%rip), %xmm0 // в регистр xmm0 копируется константа, лежащая по метке .LC1 (это 1).
        movsd   %xmm0, -24(%rbp) // в значение, расположенное по адресу (rbp - 24), копируется 1 (nextMultiplier).
        movl    $1, -28(%rbp) // в значение, расположенное по адресу (rbp - 28), копируется значение 1 (factorial).
        movl    $0, -32(%rbp) // в значение, расположенное по адресу (rbp - 32), копируется значение 0 (инициализация i).
        jmp     .L2 // безусловная передача управления метке .L2.
.L3:
        pxor    %xmm1, %xmm1 // обнуление регистра xmm1.
        cvtsi2sdl       -28(%rbp), %xmm1 // преобразование factorial к типу double.
        movsd   -48(%rbp), %xmm0 // в регистр xmm0 копируется argument.
        divsd   %xmm1, %xmm0 // в xmm0 кладется результат деления xmm0 на xmm1 (argument / factorial).
        movsd   -24(%rbp), %xmm1 // в регистр xmm1 копируется nextMultiplier.
        mulsd   %xmm1, %xmm0 // в xmm0 кладется результат произведения xmm0 на xmm1 [(argument / factorial) * nextMultiplier]
        movsd   %xmm0, -24(%rbp) // в значение, лежащее по адресу (rbp - 24) кладется этот промежуточный результат (новое значение nextMultiplier).
        addl    $1, -28(%rbp) // factorial увеличивается на 1.
        pxor    %xmm0, %xmm0 // обнуление регистра xmm0.
        cvtsi2sdl       -12(%rbp), %xmm0 // преобразование signStatus к типу double.
        mulsd   -24(%rbp), %xmm0 // в xmm0 копируется результат умножения signStatus на промежуточный результат.
                                 // сформирован множитель: signStatus * nextMultiplier (только уже новый).
        movsd   -8(%rbp), %xmm1 //  в регистр xmm1 копируется значение result.
        addsd   %xmm1, %xmm0 // в xmm0 помещается значение (result + signStatus * nextMultiplier)
        movsd   %xmm0, -8(%rbp) // в значение, лежащее по адресу (rbp - 8) копируется этот промежуточный результат.
        pxor    %xmm1, %xmm1 // обнуление регистра xmm1.
        cvtsi2sdl       -28(%rbp), %xmm1 // преобразование factorial к типу double.
        movsd   -48(%rbp), %xmm0 // в регистр xmm0 копируется argument.
        divsd   %xmm1, %xmm0 // в регистр xmm0 помещается результат деления (argument / factorial).
        movsd   -24(%rbp), %xmm1 // в регистр xmm1 копируется значение nextMultiplier.
        mulsd   %xmm1, %xmm0 // в xmm0 помещается результат умножения nextMultiplier на (argument / factorial).
        movsd   %xmm0, -24(%rbp) // в значение, лежащее по адресу (rbp - 24) копируется этот промежуточный результат (новое значение nextMultiplier).
        addl    $1, -28(%rbp) // factorial увеличивается на 1.
        negl    -12(%rbp) // в (rbp - 12) помещается результат (0 - [rbp - 12]), т.е. умножение на -1.
        addl    $1, -32(%rbp) // к значению, лежащему по адресу (rbp - 32) прибавляется 1 (++i).
.L2:
        movl    -32(%rbp), %eax  // в регистр eax копируется значение, лежащее по адресу (rbp - 32) (то есть i).
        cmpl    -36(%rbp), %eax // сравнение значения, лежащего по адресу (rbp - 36) [то есть number] с i.
        jl      .L3 // если i < number, то переход к метке .L3.
        movsd   -8(%rbp), %xmm0 // в регистр xmm0 копируется значение, лежащее по адресу (rbp - 8) (result).
        movq    %xmm0, %rax // в регистр rax копируется содержимое регистра xmm0 [неявное преобразование в double].
        movq    %rax, %xmm0 // в регистр xmm0 копируется содержимое регистра rax.
        popq    %rbp // извлечение значения с вершины стека и его запись в регистр rbp.
        ret
.LC2:
        .string "too few arguments. try again"
.LC3:
        .string "too many arguments. try again"
.LC5:
        .string "%lf\n"
.LC7:
        .string "(clock_gettime) total time: %lf sec.\n"
main:
        pushq   %rbp // помещение базы стекового фрейма на вершину стека.
        movq    %rsp, %rbp // в регистр rbp копируется адрес верхушки стека.
        subq    $64, %rsp // rsp = rsp - 64 (зарезервировали место под локальные переменные).
        movl    %edi, -52(%rbp) // по адресу (rbp - 52) записывается 4-байтовое значение edi [тут лежит argc].
        movq    %rsi, -64(%rbp) // по адресу (rbp - 64) записывается 8-байтовое значение rsi [тут лежит указатель на argv[]].
        cmpl    $2, -52(%rbp) // 4-байтовое значение, лежащее по адресу (rbp - 52) сравнивается с числом 2.
        jg      .L6 // если значение, лежащее по адресу (rbp - 52), оказалось больше числа 2, то переходим к метке .L6 (argc > 2).
        movl    $.LC2, %edi // иначе: в edi копируется 4-байтовое значение, размещенное по метке .LC2 (здесь argc <= 2).
        call    puts // выводит содержимое регистра edi в поток вывода stdout.
        movl    $0, %eax // копирует 4-байтовое значение 0 в регистр eax (индикатор завершения работы подпрограммы).
        jmp     .L9 // безусловная передача управления метке .L9.
.L6:
        cmpl    $3, -52(%rbp) // 4-байтовое значение, лежащее по адресу (rbp - 52) сравнивается с числом 3.
        jle     .L8 // если значение, лежащее по адресу (rbp - 52) оказалось <= 3, то переходим к метке .L8 (argc <= 3).
        movl    $.LC3, %edi // иначе: в регистр edi копируем 4-байтовое значение, размещенное по метке .LC3 (здесь argc > 3).
        call    puts // вывод содержимого регистра edi в поток вывода stdout.
        movl    $0, %eax // в регистр eax копируется 4-байтовое значение 0 (прерывание функции main).
        jmp     .L9 // безусловная передача управления метке .L9.
.L8:
        /* strtol */
        movq    -64(%rbp), %rax // в регистр rax кладется значение, лежащее по адресу (rbp - 64).
        addq    $8, %rax // адресная арифметика: переход к указателю на agrv[1].
        movq    (%rax), %rax // разыменование указателя, лежащего в rax. Теперь в rax лежит argv[1].
        movl    $10, %edx // в регистр edx копируется 4-байтовое значение 10.
        movl    $0, %esi // в регистр esi копируется 4-байтовое значение 0.
        movq    %rax, %rdi // в регистр rdi копируется argv[1] из регистра rax.
        call    strtol // вызов функции для регистров edx, esi, rdi (т.е. для argv[1], 0 [NULL] и 10).
        movl    %rax, -4(%rbp) // копирование в значение, лежащее по адресу (rbp - 4) результата работы функции strtol.
        
        /* strtod */
        movq    -64(%rbp), %rax // в регистр rax кладется значение, лежащее по адресу (rbp - 64).
        addq    $16, %rax // Опять адресная арифметика. Переход к указателю на argv[2].
        movq    (%rax), %rax // разыменование указателя. В регистре rax теперь лежит argv[2].
        movl    $0, %esi // в регистр esi копируется 4-байтовое значение 0.
        movq    %rax, %rdi // в регистр rdi копируется argv[2] из регистра rax.
        call    strtod // вызов функции для регистров esi, rdi (т.е. для argv[2] и 0 [NULL]).
        movq    %xmm0, %rax // в регистр rax копируется 8-байтовое значение из регистра xmm0 (результат вызова функции).
        movq    %rax, -16(%rbp) // в значение, лежащее по адресу (rbp - 16) копируется 8-байтовое значение из регистра rax.

        leaq    -32(%rbp), %rax // копирует в rax адрес элемента стека, расположенного по адресу (rbp - 32) (получение адреса экземпляра структуры start_clock).
        movq    %rax, %rsi // в регистр rsi копируется адрес из регистра rax.
        movl    $4, %edi // в регистр edi копируется 4-байтовое значение 4 (CLOCK_MONOTONIC_RAW).
        call    clock_gettime // вызов функции для регистров edi и rsi.

        movsd   -16(%rbp), %xmm1 // в регистр xmm1 копируется результат работы функции strtod.
        movsd   .LC4(%rip), %xmm0 // в регистр rip кладется константа из .LC4, а потом его содержимое копируется в регистр xmm0.
        mulsd   %xmm0, %xmm1 // в регистр xmm1 кладется strtod(argv[2]) * 0.017453; второй аргумент функции CalcSin сформирован.
        movq    %xmm1, %rdx // в регистр rdx копируется 8-байтовое значение из регистра xmm1, то есть второй аргумент CalcSin.
        movl    -4(%rbp), %eax // в регистр eax копируется результат работы функции strtol.
        movq    %rdx, %xmm0 // в регистр xmm0 копируется второй аргумент функции CalcSin.
        movl    %eax, %edi // в регистр edi копируется 4-байтовое значение из регистра eax, то есть первый аргумент CalcSin.
        call    CalcSin // вызов функции для регистров edi и xmm0 (т.е. для strtol(argv[1]) и strtod(argv[2]) * 0.017453).
        movq    %xmm0, %rax // результат работы функции CalcSin копируется в регистр rax [неявное преобразование в double].
        movq    %rax, %xmm0 // в регистр xmm0 копируется содержимое регистра rax.
        movl    $.LC5, %edi // в регистр edi копируется значение, размещенное по метке .LC5.
        movl    $1, %eax // в регистр eax копируется значение 1 (кол-во аргументов неинтегрального типа).
        call    printf

        leaq    -48(%rbp), %rax // копирует в rax адрес элемента стека, расположенного по адресу (rbp - 48) (получение адреса экземпляра структуры start_clock).
        movq    %rax, %rsi // в регистр rsi копируется содержимое регистра rax.
        movl    $4, %edi // в регистр edi копируется значение 4 (CLOCK_MONOTONIC_RAW).
        call    clock_gettime // вызов функции clock_gettime для регистров edi и rsi.

        movq    -48(%rbp), %rdx // в регистр rdx копируется end_clock.
        movq    -32(%rbp), %rax // в регистр rax копируется start_clock.
        subq    %rax, %rdx // в регистр rdx помещается результат: end_clock.tv_sec - start_clock.tv_sec.
        pxor    %xmm1, %xmm1 // обнуление регистра xmm1.
        cvtsi2sdq       %rdx, %xmm1 // преобразование end_clock.tv_sec - start_clock.tv_sec к типу double.
        movq    -40(%rbp), %rdx // в регистр rdx копируется значение, лежащее по адресу (rbp - 40) (end_clock.tv_nsec)
        movq    -24(%rbp), %rax // в регистр rax копируется значение, лежащее по адресу (rbp - 24) (start_clock.tv_nsec)
        subq    %rax, %rdx // в rdx помещается результат: end_clock.tv_nsec - start_clock.tv_nsec.
        pxor    %xmm2, %xmm2 // обнуление регистра xmm2.
        cvtsi2sdq       %rdx, %xmm2 // преобразование end_clock.tv_nsec - start_clock.tv_nsec к типу double.
        movsd   .LC6(%rip), %xmm0 // в регистр xmm0 копируется значение константы, лежащей по метке .LC6.
        mulsd   %xmm2, %xmm0 // умножение (double) end_clock.tv_nsec - start_clock.tv_nsec на 0.000000001.
        addsd   %xmm0, %xmm1 // в регистр xmm1 помещается сумма значений из xmm0 и xmm1.
        movq    %xmm1, %rax // в регистр rax копируется значение регистра xmm1.
        movq    %rax, %xmm0 //в регистр xmm0 копируется значение регистра rax.
        movl    $.LC7, %edi // в регистр edi помещается строковый литерал, расположенный по метке .LC7.
        movl    $1, %eax // в регистр eax копируется значение 1 (кол-во аргументов неинтегрального типа).
        call    printf
        movl    $0, %eax // в регистр eax копируется значение 0 (индикатор завершения работы подпрограммы).
.L9:
        leave // сначала: [movl %rbp, %rsp] -> затем -> [pop %rbp] (восстановление состояние стека и кадра, которые были до вызова).
        ret // возврат из подпрограммы.
.LC1:
        .long   0
        .long   1072693248 // эта константа равна: (-1)^0 * 1.0000000000000000000000000000000000000000000000000000 * 2^(1023 - 1023) = 1.
.LC4:
        .long   14568529
        .long   1066524467 // эта константа равна: (-1)^0 * 1.0001110111110011001100000000110111100100110001010001 * 2^(1017 - 1023) = 0.017453.
.LC6:
        .long   -400107883
        .long   1041313291 // эта константа равна: (-1)^0 * 1.0001001011100000101111101000001001101101011010010101 * 2^(993 - 1023) = 0.000000001.
